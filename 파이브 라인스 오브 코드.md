# 파이브 라인스 오브 코드

### 1장. 리팩터링 리팩터링하기

- 리팩터링이란 기능을 유지한 채 변경하는 것을 말합니다.
    - 스킬, 문화, 도구 3가지 요소의 교집합에 있습니다. 요소들은 코드 스멜을 캐치하는 법, 리팩토링을 꼭 필요한 것으로 인식하는 것, 리팩토링의 효과를 올려줄 자동화된 테스트를 의미합니다.
- 흔히들 클린 코드, 좋은 코드라고 말하는 것의 명확한(?) 정의를 여기서 저자는 언급합니다.
    - 사람이 읽기 쉽고, 유지보수가 용이하며, 의도한 대로 잘 동작하는 코드. 위와 합치면 리팩토링이 어떤 조건에서 어떤 결과를 이뤄내야 하는지가 명확해집니다.
- 저자는 개발 작업의 절차를 ‘**탐색 → 명세화 → 구현 → 테스트 → 리팩터링 → 전달**’ 로 구분합니다. 여기서 개인적으로 생각하는 리팩터링의 필수 조건이 나타나는데 바로 테스트입니다.
    - 리팩터링은 기존 코드의 온전한 동작을 보장한 상태로 이뤄져야 합니다. 이 때 온전한 동작을 가장 쉽고 빠르게 보장할 수 있는 것이 **코드 베이스에 대한 자동화된 테스트**입니다.
    - 만약 자동화된 테스트가 없다면, 자동화되지 않았더라도 기존 코드의 모든 동작을 기록하고 새로운 코드가 이전과 같은 동작을 수행한다는 것을 확인하지 않는다면 리팩토링은 절대 일어나선 안됩니다.
    - 레거시가 레거시로 남을 수 있는 것은 이미 잘 돌아가고 있기 때문입니다.

### 2장. 리팩토링 깊게 들여다보기

- 범위가 제한되지 않는 불변속성을 제거합시다.
    - 예시에서는 urgency를 계산하는데에 daysUntilExpiry가 사용된다는 것을 전구 객체에서 알아차리지 못하는 것이 문제였습니다.
    - Merchandise라는 상위 클래스에 daysUntilExpiry 필드가 존재하고 이를 상속하는 구조이지 않았을까 싶습니다.
    - 저자가 이야기한 것처럼 calculateUrgency() 메서드에서 daysUntilExipry가 0인 경우를 확인(변수 체크)하여 런타임 예외를 반환하는 방법이 있을 것 같습니다.
        
        ```jsx
        public void calculateUrgency(){
        		if(isExpiryDayIsZero()){
        				throw new IllegalStatusException("Urgency cannot be calculated with expiry day with zero value");
        		}
        		...
        }
        ```
        
    - 다르게는 타입을 이용하여(daysUntilExipry 클래스 정의) 0이 되지 않도록 만들어 봅시다.
        
        ```jsx
        public class DaysUntilExpiry {
        	private int days;
        
        	public DaysUntilExpiry(int days){
        		validateDays();
        		setDays(days);
        	}
        
        	private void setDays(int days){
        		this.days = days;
        	}
        
        	private void validateDays(){
        			if(days == 0){
        					throw new IllegalArgumentException("Expiry day cannot be zero");
        			}
        	}
        }
        ```
        
        - 이렇게 설계된다면 전구 객체를 생성하려고 할 때 0으로는 품목이 생성되지 않겠죠. 그리고 왜 만료일에 0은 들어갈 수 없는지 팀원들에게 컨텍스트를 물어볼 겁니다.
        - 이처럼 타입으로 제한할 수 있는 경우가 좋다고 여겨집니다.
    - **불변속성의 범위 → 함께 변하는 것은 함께 있어야 한다**
- 상속보단 컴포지션을 활용해 객체 결합도가 과하게 복잡해지는 것을 막으세요.
- 도메인 전문가와 긴밀하게 협력하여 실세계에서 일어날 수 있는 코너 케이스(변수, 환경 요소로 인해 코드에 문제가 발생하는 케이스)를 같이 발견하세요.

---

### 3장. 긴 코드 조각내기

- 먼저 메서드 하나가 5줄 안으로 끝나도록 해봅시다.
    - 긴 메서드를 수행하는 동작의 시작과 끝에 맞춰 적절하게 나눕니다.
    - 이를 ‘메서드 추출’ 기법을 활용해 도우미 메서드로 분리합니다.
        - 인텔리제이와 같은 IDE를 활용하면 직접 메서드를 생성하고 소스코드를 복사하고 붙여넣는 불편함을 겪지 않아도 됩니다.
- 도우미 메서드를 활용해 나눴다면, 그 뒤엔 **호출하거나 전달하거나 한 가지**만 하도록 만듭니다.
    - 말로만 봐선 조금 헷갈립니다. 예제 코드를 보고 이해해보죠.
        
        ```tsx
        function draw() {
          let canvas = document.getElementById("GameCanvas") as HTMLCanvasElement;
          let graphic = canvas.getContext("2d");
        
        	// Clear Rectangle Of This Positions (0, 0, canvas.width, canvas.height)
        	clearRectagleOfThisPositions(0, 0, canvas.width, canvas.height);
        	
        	// >>> None abstract lines
        	g.clearRect(0, 0, canvas.width, canvas.height);
        	g.~
        	g.~
        	g.~
        	// >>> None abstract lines
        
        	drawMap(g); // 높고
        	drawPlayer(g);
        }
        ```
        
    - 이처럼 리팩토링을 수행하면 g 변수가 너무 많은 일을 수행하게 됩니다.
        - `clearRect(..)` 를 호출하면 캔버스의 전체 영역을 지우는 로우 레벨의 동작을 수행합니다. 이는 단순한 한 줄의 코드이지만 g 변수에서 수행되는 일들을 g가 호출하는 메서드 이름으로 파악해야 합니다.
        - 반면 drawMap(g), drawPlayer(g)에서는 맵과 캐릭터를 그리는, 보다 복잡한 동작의 인자로 사용됩니다. 즉 clearRect(..)의 추상화 수준보다 한단계 높은 함수의 인자로 사용되는 것이죠.
        - 후에 Graphic이라는 단어가 나오긴 하지만, 애초에 UI단의 이해가 없는 저는 g가 어떤 단어의 축약인지도 모르겠습니다.
    - 저자는 아래와 같이 수정함으로써 메서드의 추상화 단계를 통일합니다.
        
        ```tsx
        function createGraphics(){
        		...
        }
        
        function draw() {
        		let g = createGraphics()
        		drawMap(g);
        		drawPlayer(g);
        }
        ```
        
        - 여기서 저는 몇 가지를 보완해봤습니다.
        
        ```tsx
        function create**Cleared**Graphic~~s~~(){
        		...
        }
        
        function draw() {
        		let **graphic** = create**Cleared**Graphic()
        		drawMap**On**(graphic);
        		drawPlayer**On**(graphic);
        }
        ```
        
        - 생성된 그래픽이지만 내부적으로 `clearRect(..)` 가 호출됐기에 cleared 라는 단어를 Graphic 앞에 추가했습니다.
        - 또한 canvas 변수를 할당할 때 document 객체에서 ID를 통해 HTMLCanvasElement를 가져옵니다. ID는 유일한 식별자를 의미하여 하나만 가져와지는 경우를 고려해 Graphics를 단수로 변경했습니다.
        - 개인적으로 메서드와 인자가 유려한 문장으로 읽히는 편을 좋아합니다. 맵과 캐릭터를 그리는 대상이 되는 Graphic 앞에 전치사 on을 추가했습니다.
- 마지막으로 if문을 함수의 시작에 배치해 너무 많은 일을 하는 함수를 쪼개봅시다.
    - 우리는 일반적으로 인자 혹은 인스턴스 필드의 상태를 조회하고 if문을 사용해 분기를 나눕니다. 이후 어떤 동작들을 수행하죠. 여기서 우리가 수행한 동작은 **조회, 판별, 동작 수행** 세 가지로 나눌 수 있습니다. 저자는 세 가지를 모두 쪼개는 것을 권합니다.
    - ASIS
        
        ```tsx
        function updateMap(){
        	// 2차원 배열 m를 순회합니다. 순회 동작은 메서드 추출이 불가능하며 의미도 없습니다. 배제합니다.
        	for (let y = map.length - 1; y >= 0; y--) {
            for (let x = 0; x < map[y].length; x++) {
        			// 배열 내의 특정 요소들을 **조회(map[y][x])**하고, **판별(===)**합니다.
              if ((map[y][x] === Tile.STONE || map[y][x] === Tile.FALLING_STONE)
                && map[y + 1][x] === Tile.AIR) {
        				// 이후 **동작들을 수행**하죠.
                map[y + 1][x] = Tile.FALLING_STONE;
                map[y][x] = Tile.AIR;
              } else if ((map[y][x] === Tile.BOX || map[y][x] === Tile.FALLING_BOX)
                && map[y + 1][x] === Tile.AIR) {
                map[y + 1][x] = Tile.FALLING_BOX;
                map[y][x] = Tile.AIR;
              } else if (map[y][x] === Tile.FALLING_STONE) {
                map[y][x] = Tile.STONE;
              } else if (map[y][x] === Tile.FALLING_BOX) {
                map[y][x] = Tile.BOX;
              }
            }
          }
        }
        ```
        
    - TOBE
        
        ```tsx
        function updateMap(){
        	// 2차원 배열 m를 순회합니다. 순회 동작은 메서드 추출이 불가능하며 의미도 없습니다. 배제합니다.
        	for (let y = map.length - 1; y >= 0; y--) {
            for (let x = 0; x < map[y].length; x++) {
        			**updateTile(x,y);**
            }
          }
        }
        ```
        
    - 2차원 배열의 요소들을 순회하며 값을 열거형과 비교하고, 이후 동작들을 수행하는 것을 하나의 큰 덩어리로 추상화합니다. `updateTile(..)` 이라는 메서드로요.
    - 이제 `updateMap()` 메서드는 2차원 배열의 요소들을 수행하며 수정하는 작업을 진행하는 동작을 수행한다는 사실을 단 3줄만에 알 수 있게 됐습니다. 그 안에서 어떤 디테일들이 있는지는 도우미 메서드 안에서 파악할 수 있죠.
    - 만약 저자가 허락한다면 조금 과할수도 있겠지만 이렇게도 더 쪼개보면 어떨까요.
        
        ```tsx
        function updateTile(x, y) {
        		if (isStone(x,y) || isFallingStone(x,y) && bottomIsAir(x,y)){
        				dropStoneTo(x,y)
        		} 
        		else if (isBox(x,y) || isFallingBox(x,y) && bottomIsAir(x,y)){
        				dropBoxTo(x,y)
        		}
        		else if(isFallingStone(x,y)){
        				map[y][x] = Tile.STONE;
        		}
        		else if(isFallingBox(x,y)){
        				map[y][x] = Tile.STONE;
        		}
        }
        ```
        
- 이어지는 `handleInputs(..), handleInput(..)` 예시는 `updateTile(..)` 메서드 추출과 의미하는 바가 같아 생략합니다.

---

### 4장. 타입 코드 처리하기

- 이전 장에 이어 if-else 체인을 제거해보겠습니다. 처음엔 단순히 else를 사용하지 말라는 규칙이 그럼 if로 바꿔서 쓰라는건가? 싶었습니다. 하지만 해결방법은 역시 한 차원 높은 객체지향 활용에 있었습니다.
- 먼저 첫번째 if-else 제거 전략은 다형성을 활용해 각 조건절의 후실행 코드를 클래스로 이관하는 것입니다.
    - 위에서 리팩토링한 `updateTile(..)` 메서드 이전엔 inputs의 목록에서 값들을 가져와 상하좌우를 구분해 수직, 수평으로 움직이는 작업이 필요했습니다. 코드는 이렇습니다.
        
        ```java
        while (inputs.length > 0) {
          let current = inputs.pop();
          if (current === Input.LEFT)
            moveHorizontal(-1);
          else if (current === Input.RIGHT)
            moveHorizontal(1);
          else if (current === Input.UP)
            moveVertical(-1);
          else if (current === Input.DOWN)
            moveVertical(1);
        }
        ```
        
        - Input은 열거형 타입으로 선언되어있고, 타입에 맞춰서 `moveHorizontal(..)` 과  `moveVertical(..)`을 호출합니다.
    - 위 코드를 살펴보면 LEFT, RIGHT, UP, DOWN 열거형 타입이 나타내는 것은 방향을 표현하는 객체입니다. 또한 수직 혹은 수평으로 움직이는 행위를 클라이언트에게 요청받기도 하죠. 그렇다면 이는 추상화의 대상이 될 수 있습니다.
        - 우리가 지켜야할 규칙은 **열거형은 인터페이스로,** **열거형의 값들은 클래스로 변환**하는 것입니다.
    - 위 규칙을 지켜 리팩토링한 결과는 아래와 같습니다.
        
        ```java
        interface Input {
        		void handle();
        }
        
        class Left implements Input {
        
        		@Override
        		void handle(){
        				moveHorizontal(-1);
        		}
        }
        
        class Right implements Input {
        
        		@Override
        		void handle(){
        				moveHorizontal(1);
        		}
        }
        
        class Up implements Input {
        
        		@Override
        		void handle(){
        				moveVertical(-1);
        		}
        }
        
        class Down implements Input {
        
        		@Override
        		void handle(){
        				moveVertical(1);
        		}
        }
        ```
        
        - `moveHorizontal(..)` 과  `moveVertical(..)` 은 내부적으로 map, playerx, playery 등의 상태가 필요합니다. 생성자에서 이를 주입한다고 과정하고 위 코드에서는 생략하겠습니다.